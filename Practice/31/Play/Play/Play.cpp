/*			Ответы на вопросы:

После того,как я сравнил адреса элементов вектора с одинаковыми индексами, то сделал вывод


1) При передаче по ссылке не создаётся копия вектора.
Адреса первых элементов всегда разные, потому что вектор копируется в новый
участок памяти (старый очищается) при добавлении нового элемента, если возможность
расположить элементы последовтально отсутствуют. Поэтому адреса изменяются.


2) Из-за того, что вектор переместиться в новую память, значение нулевой ячейки вектора не измениться.


3) Адреса элемента вектора всегда отличаются, т.к. с помощью оператора << вектор копируется,
а так как элементы идут последовательно,то адреса следующих элементов увеличиваются на размер того, сколько байт занимает int)
Нет, потому что вектор будет перемещён в новую память..


4) При передаче по значению при по попадании в функцию каждый раз создаётся новый вектор,
поэтому адреса разные и при удалении.
*/

#include<iostream>

#include<fstream>

#include<vector>

using namespace std;

//перегружаем << для первой части

/*ostream& operator << (ostream& a, const vector<int>& list) {
	
	a << list.size() << "\t" << "| ";
	
	for (int i = 0; i < list.size(); i++) {
		
		a << &list[i] << " ";
	
	}
	
	a << endl;
	
	return a;
}
*/

//перегружаем << для третьей части
ostream& operator << (ostream& a, const vector<int> list) {
	
	a << list.size() << "\t" << "| ";
	
	for (int i = 0; i < list.size(); i++) {
	
		a << &list[i] << " ";
	
	}
	
	a << endl;
	
	return a;
}

int main() {
	
	vector<int> list;

	ofstream file;
	
	file.open("data.txt");
	
	int temp = 228;
	
	size_t vector_size = 64;
	
	for (int i = 0; i < vector_size; i++) {
		
		list.push_back(temp);
		
		file << list;
	
	}
	
	for (int i = 0; i < vector_size; i++) {
		
		list.pop_back();
		
		file << list;
	
	}
	
	file.close();

}